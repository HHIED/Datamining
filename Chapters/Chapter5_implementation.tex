%!TEX root=../main.tex
% Chapter Template

\chapter{Implementation} % Main chapter title

\label{Chapter5} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

\section{Solution overview}

The final solution consists of a \gls{REST} API build with ASP.NET Core and a MongoDB \gls{NoSQL} database. Both are hosted through Amazon Webservices in an EC2 container using Docker. \\
The API consists of the commands seen in Appendix \ref{APICommands}. \\

This section covers the realization of the design derived from the requirements and the analysis.

\section{The product recommendation algorithm}
There are multiple ways to implement a product recommendation algorithm all with their advantages and disadvantages. The method chosen for this project is called Item-to-Item collaborative filtering. Other methods and the reasoning why these were not chosen is described in further detail in Chapter \ref{Chapter3}. \\\\

Item-to-Item collaborative filtering is a data mining method to link items (products) with other items in terms of their similarity. This method is also the way \gls{Amazon} handles their product recommendations \cite{AmazonRecommendations}. \\
The specifics of the algorithm differs from implementation to implementation. In this version each product is compared to other products based on how much they have been viewed together by customers, the likeness of their description and their product group. \\
The first run of the algorithm requires going through each product and the visitors of each product to see what else they have looked at. This needs a lot of resources, but once run only new behavior has to be re-calculated. Pseudo code of the algorithm can be seen in algorithm \ref{alg:collaborativeFilter}. At line 1 a for-loop is initiated, iterating through all products in the system. Line 2 prepares a dictionary where the similarity scores of the product will be stored. Line 3-11 loops through all visitors who have looked at the product. For each visitor (line 3) a loop is initiated that loops through all products the visitor have looked at (line 4). In line 5 a check is made to see if the dictionary, containing the product similarity scores, already contain the product. If so, the score of that product is incremented by 1 (line 6). If not, the product is added to the dictionary (line 8). Once all the products that the visitor has shown interest in is looped through, the next visitor is examined. Once all visitors associated with the product are examined, the product scores are sorted descending (line 12). Once all products related to the product \textit{p} is found, the final similarity score is calculated for each of these products (line 13-15). Finally the product similarity scores are sorted descending and the top 10 most similar products to product \textit{p} are stored in the database (line 17-18), and the same procedure is done to the next product. The calculation of the similarity score can be seen in algorithm \ref{alg:calculateSimilarity}. The main product (\textit{p} from algorithm \ref{alg:collaborativeFilter}) is compared to a related product from \textit{productScores} calculated in algorithm \ref{alg:collaborativeFilter}. If the two products shares the same product group, the \textit{productGroupFactor} is set (line 4-6). Then the description of the two products are compared (line 8-12). For each word that matches in the two descriptions, the \textit{numOfSimAttributes} is incremented by 1. If there is no similar words in the two descriptions, the \textit{similarAttributeFactor} is set to 0. Finally the similarity score can be calculated (line 16).\\\\

\begin{algorithm}[H]
\caption{Item-to-Item collaborative filtering algorithm}
\label{alg:collaborativeFilter}
\begin{algorithmic}[1]
\ForAll{Products p}
\State productScores = Dictionary<int, double>
\ForAll{Visitors in p}
\ForAll{Products visitorProduct in VisitorBehaviors}
\If{productScores contains visitorProduct}
\State productScores[visitorProduct]++
\Else
\State productScores.Add(visitorProduct, 1)
\EndIf
\EndFor
\EndFor
\State Sort productScores descending
\ForAll{Products relatedProduct in productScores}
\State productScores[relatedProduct] =
\State \textbf{calculateSimilarityScore(p, relatedProduct, productScores[relatedProduct])} (see algorithm \ref{alg:calculateSimilarity})
\EndFor
\State Sort productScores descending
\State Store top 10 productScores in database under p
\EndFor
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{Similarity calculations for two products }
\label{alg:calculateSimilarity}
\begin{algorithmic}[1]

\State \textbf{calculateSimilarityScore(mainProduct p1, compareProduct p2, currentScore)}
\State similarAttributeFactor = 0.02
\State productGroupFactor = 0
\State numOfSimAttributes = 0
\If{p1.productGroup equals p2.productGroup}
\State productGroupFactor = 0.02
\EndIf
\ForAll{words w in p1.description}
\If{w is in p2.description}
\State numOfSimAttributes++
\EndIf
\EndFor
\If{numOfSimAttributes equals 0}
\State similarAttributeFactor = 0
\EndIf
\State \textbf{return} \begin{math} currentScore * (1+productGroupFactor)*(1+similarAttributeFactor^{numOfSimAttributes}) \end{math}
\end{algorithmic}
\end{algorithm}


After algorithms \ref{alg:collaborativeFilter} and \ref{alg:calculateSimilarity} each product in the database now has an array with the top 10 similar products based on amount of views, description and product group. \\
The next step is calculating the top products for each visitor, these are the products the specific visitor has viewed the most. This calculation can be seen in algorithm \ref{alg:topProducts}. In line 1 a loop is initiated, which iterates through each visitor. In line 2 a dictionary is prepared to contain all products the visitor have shown interest in as keys, and the amount of times he have looked at these as the value. Line 2-5 checks all behavior stored on the visitor (key of visitorProducts), and increment the value by 1. In line 6 the products are sorted descending, and the 5 products that the visitor have shown greatest interest in, is stored in the database (line 7). This calculation also requires a large amount of resources the first time, but very little to maintain.

\begin{algorithm}[H]
\caption{Calculations of each visitors top products}
\label{alg:topProducts}
\begin{algorithmic}[1]
\ForAll{Visitors v}
\State visitorProducts = Dictionary<string, int>
\ForAll{Behaviors b in v}
\State vistorProducts[b.Id]++
\EndFor
\State Sort visitorProducts descending
\State Store top 5 visitorProducts in database under v
\EndFor
\end{algorithmic}
\end{algorithm}

Since all these calculations are made before the actual product recommendations are requested, the process of recommending products is quite fast. The pseudo code for the recommendation part can be seen in algorithm \ref{alg:recommendation}. The recommendation process starts with retrieving the requested visitor's top products from the database (line 1). In line 2 a dictionary is prepared to contain the final product recommendations. A for loop is initiated to iterate through all products \textit{p} in \textit{visitorTopProducts} (line 3). The similar products of the product \textit{p} is retrieved from the database (line 4). Each of these similar products are added to the \textit{productRecommendations} dictionary with their similarity score, or added to the summarized score if it already exists (line 6-9). Finally \textit{productRecommendations} is sorted descending, and the requested amount of recommendations are returned (line 13-14). 

\begin{algorithm}[H]
\caption{Get product recommendations}
\label{alg:recommendation}
\begin{algorithmic}[1]
\State visitorTopProducts = db.GetTopProducts(visitorUID)
\State productRecommendations = Dictionary<int, double>
\ForAll{Products p in visitorTopProducts}
\State similarProducts = db.GetTopProductRecommendation(p)
\ForAll{products simProduct in similarProducts}
\If{productRecommendations contains simProduct}
\State productRecommendations[simProduct] += similarProducts[simProduct]
\Else
\State productRecommendations.add(simProduct, similarProducts[simProduct]
\EndIf
\EndFor
\EndFor
\State Sort productRecommendations descending
\State \textbf{return} amount of productRecommendations requested
\State 
\end{algorithmic}
\end{algorithm}

The entire process of requesting product recommendations, running algorithm \ref{alg:recommendation} and returning them takes less than 40ms which satisfies the non-functional requirement NF02. \\\\
Some other paths are required in certain situations such as when the visitor does not have any behavior or not enough behavior to satisfy the amount of recommendations requested. In these cases the remaining recommendations are filled from the top 20 most popular products in the last 30 days. The top 20 products are calculated by checking the timestamp and finding those in the last 30 days and then counting how many times each product was viewed. The top 20 products are stored in the database and can be calculated through an API call.

\section{Handling new data}
When new visitors are created or new behavior is discovered the client has to call the corresponding API functions in order to store this data alongside the other. When new behavior data is registered the program re-calculates the visitor's top product as well as the product's similar products. This way the algorithm is always up to date and the calculations can happen asynchronously and thereby have no affect the load times for the end user.

\section{Hosting the API}
This product recommendation API is hosted through Amazon WebServices in an \gls{EC2Instance} \cite{EC2}. To accomplish this the ASP.NET core project is built in a Docker container, the container is pushed to the Docker Hub and then pulled and run in the \gls{EC2Instance}. Docker is a tool that can be used to deploy applications within software containers. When a project is wrapped in a Docker container, all necessary files from the system environment is wrapped as well. Docker itself is based off the Linux kernel, and can therefore be deployed on any Linux server \cite{Docker}.  The database is similarly packed in a docker container and run in the \gls{EC2Instance}. The Docker containers have exposed ports to the rest of the internet and can be accessed via \gls{EC2Instance} public DNS or IP.



			


 