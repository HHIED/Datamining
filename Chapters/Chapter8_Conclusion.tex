%!TEX root=../main.tex
% Chapter Template

\chapter{Conclusion} % Main chapter title

\label{Conclusion} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

This section answers the problem definition and takes a look at how many of the requirements were fulfilled.

\section{Problem definition and research questions}

The original problem definition was supplied by \gls{Struct} and involves them using their logged user activity data to create a personalized experience for the users. The final solution is an \gls{API} giving tailored product recommendations to the end users based on their behavior on the website. The \gls{API} allows for an easy way to add and maintain data about each visitor to keep recommendations up-to-date. \\
The problem definition derived the following three research questions "How can large amounts of data be optimally organized, stored and accessed in a scalable way?",  "How can this data be maintained and updated easily after deployment?" and How can the organized data be utilized to generate tailored product recommendations for the end user?". These questions are answered below.

\subsection{How can large amounts of data be optimally organized, stored and accessed in a scalable way?}
\gls{MongoDB}, a \gls{NoSQL} database, was chosen in order to accomplish scalable accessing and storing of the data provided by \gls{Struct}. \gls{MongoDB} provides scaling functionalities due to its denormalized data which can more easily be spread across multiple servers \cite{SQLvsNOSQL}. \gls{NoSQL} services on platforms such as Azure or \gls{amazonwebservice} have built in scaling functions \cite{azureNoSQL} which gives the distinct advantage that even if the data grows exponentially the hardware can keep up. The scaling functionality was not used, due to limited funds. Accessing all information about a certain user or product is simple due to the denormalized structure. Overall \gls{MongoDB} is a good fit for this type of project with growing data needs.

\subsection{How can this data be maintained and updated easily after deployment?}
Maintaining and updating the data is as simple as calling the \gls{API} functions when new data is produced. When a new visitor visits the site an \gls{API} function will store the visitor in the database, similarly new behavior data is stored by calling another \gls{API} function. These functions can be called asynchronously meaning no extra load times for the end user.

\subsection{How can the organized data be utilized to generate tailored product recommendations for the end user?}
The data can be utilized through \gls{datamining}. The \gls{datamining} technique used to generate product recommendations in the project is Item-to-Item \gls{collaborativefiltering}. This process creates links between products based on their similarity and end users can thereby receive product recommendations based on the products they have already looked at. The recommendations are based on the entire user-base and assumes users have similar tastes and purchasing patterns.

\section{Requirements fulfillment}
The requirements engineering process created 15 functional and 4 non-functional requirements. Of these requirements the most important one is F01 which is successfully met. The functional requirements F02, F03, F05 and F06 have also been met. The remaining functional requirements are not met but are not imperative for generating product recommendations. The \gls{API} is developed in \gls{aspnet}. The data is stored in a \gls{NoSQL} database. The \gls{API} is accessible through the gls{DockerContainer} hosted on \gls{amazonwebservice}. Finally the product recommendations are generated in less than 40ms which means all non-functional requirements have been met.
